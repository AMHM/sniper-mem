#!/usr/bin/env python

import sys, os, time, getopt, tempfile, subprocess, threading, platform, pprint, Queue, socket, pipes, commands
sys.path.append(os.path.join(os.path.dirname(__file__), 'tools'))
import sniper_lib, gen_simout, debugpin


HOME = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0])))


def usage():
  print 'Run program under the Sniper simulator'
  print 'Usage:'
  print '  %s  [-n <ncores (1)>]  [-d <outputdir (.)>]  [-c <sniper-config>]  [-c [objname:]<name[.cfg]>,<name2[.cfg]>,...]  [-g <sniper-options>]  [--roi]  [--roi-script]  [--perf]  [--gdb]  [--gdb-wait]  [--gdb-quit]  [--appdebug]  [--appdebug-manual]  [--appdebug-enable]  [--power]  [--cache-only]  [--fast-forward]  [--no-cache-warming]  [--save-patch]  [--pin-stats]  [--mpi [--mpi-ranks=<ranks>] ]  {--traces=<trace0>,<trace1>,... [--response-traces=<resptrace0>,<resptrace1>,...] | -- <cmdline>}' % sys.argv[0]
  print
  print 'Example: $ ./run-sniper -- /bin/ls'
  print
  print 'Note: To get started quickly with our integrated benchmarks distribution (supports SPLASH-2 and PARSEC 2.1),'
  print ' see http://snipersim.org/w/Download_Benchmarks'
  print
  sys.exit(2)

standalone = False
ncores = 1
outputdir = '.'
graphiteoptions = []
config_file_used = False
roi_only = False
roi_script = False
use_perf = False
use_gdb = False
gdb_wait = False
gdb_quit = False
use_appdebug = False
appdebug_manual = False
appdebug_nowait = False
run_power = False
save_patch = False
pin_stats = False
curdir = os.getcwd()
scripts = []
use_mpi = False
mpi_ranks = 0
traces = []
resptraces = []
trace_manual = False
heteroconfig = None

if not sys.argv[1:]:
  usage()

def findconfig(filename, extension = '.cfg'):
  for dirname in ('.', os.path.join(HOME, 'config')):
    configfile = os.path.realpath(os.path.join(dirname, filename))
    if os.path.isfile(configfile):
      return configfile
    configfile += extension
    if os.path.isfile(configfile):
      return configfile
  return False

def add_config_file(filename, extension = '.cfg'):
  config_files = []
  configfile = findconfig(filename, extension)
  if not configfile:
    print 'Cannot find config file', filename
    sys.exit(1)
  # Handle #include
  for line in file(configfile):
    if line.startswith('#include'):
      config_files += add_config_file(line.split()[1], extension)
  config_files += ['--config=' + configfile]
  return config_files

def make_hetero_config(confignames, objname='core', extension='.cfg'):
  configfiles = map(lambda x:findconfig(x,extension), confignames)
  configfiledata = map(lambda x:open(x).read(), configfiles)
  configs = map(sniper_lib.parse_config, configfiledata)

  # Generate a set of all config options
  opts = set()
  for config in configs:
    for key in config.keys():
      opts.add(key)

  # Combine all of the heterogeneous configurations
  newconfig = ''
  newconfig += '# Generated from ' + ', '.join(set(configfiles)) + '\n'
  for opt in opts:
    title, _, key = opt.rpartition('/')
    newconfig += '[%s]\n%s=' % (title,key)
    heteroopts = []
    for config in configs:
      if opt in config:
        heteroopts.append(config[opt])
      else:
        heteroopts.append('')
    newconfig += ','.join(heteroopts)+'\n'

  # Create initial tags for the heterogeneous configurations
  # The tags are the basename without the extension.
  # config/big.cfg with have the tag 'big'
  tags = map(lambda x:os.path.splitext(os.path.split(x)[1])[0], configfiles)
  for tag in set(tags):
    enabled = map(lambda x:(x == tag) and '1' or '0', tags)
    newconfig += '[tags/%s]\n' % objname
    newconfig += '%s=%s\n' % (tag,','.join(enabled))

  return newconfig


try:
  opts, cmdline = getopt.getopt(sys.argv[1:], "hn:m:d:c:g:s:", [ "roi", "roi-script", "perf", "gdb", "gdb-wait", "gdb-quit", "appdebug", "appdebug-manual", "appdebug-enable", "power", "cache-only", "fast-forward", "no-cache-warming", "save-patch", "curdir=", "pin-stats", "traces=", "response-traces=", "trace-manual", "mpi", "mpi-ranks=" ])
except getopt.GetoptError, e:
  # print help information and exit:
  print e
  usage()
for o, a in opts:
  if o == '-h':
    usage()
    sys.exit()
  if o == '-n':
    ncores = int(a)
  if o == '-d':
    outputdir = a
  if o == '-c':
    if ':' in a or ',' in a:
      obj, _, cfg = a.rpartition(':')
      if not obj:
        obj = 'core'
      heteroconfig = make_hetero_config(cfg.split(','), objname=obj)
    else:
      config_file_used = True
      graphiteoptions += add_config_file(a)
  if o == '-g':
    if not a.startswith('-'):
      a = '--'+a
    graphiteoptions.append(pipes.quote(a))
  if o == '--roi':
    roi_only = True
  if o == '--roi-script':
    roi_script = True
  if o == '-s':
    scripts.append(a)
  if o == '--perf':
    use_perf = True
  if o == '--gdb':
    use_gdb = True
  if o == '--gdb-wait':
    use_gdb = True
    gdb_wait = True
  if o == '--gdb-quit':
    use_gdb = True
    gdb_wait = False
    gdb_quit = True
  if o == '--appdebug':
    use_appdebug = True
  if o == '--appdebug-manual':
    use_appdebug = True
    appdebug_manual = True
  if o == '--appdebug-enable':
    use_appdebug = True
    appdebug_nowait = True
  if o == '--power':
    run_power = True
  if o == '--cache-only':
    graphiteoptions.append('-g --general/inst_mode_roi=cache_only')
  if o == '--fast-forward':
    graphiteoptions.append('-g --general/inst_mode_init=fast_forward')
    graphiteoptions.append('-g --general/inst_mode_roi=fast_forward')
  if o == '--no-cache-warming':
    graphiteoptions.append('-g --general/inst_mode_init=fast_forward')
  if o == '--save-patch':
    save_patch = True
  if o == '--pin-stats':
    pin_stats = True
  if o == '--curdir':
    curdir = a
  if o == '--traces':
    traces.extend(a.split(','))
  if o == '--response-traces':
    resptraces.extend(a.split(','))
  if o == '--trace-manual':
    trace_manual = True
  if o == '--mpi':
    use_mpi = True
  if o == '--mpi-ranks':
    mpi_ranks = long(a)


if cmdline:
  if use_mpi:
    standalone = True
  else:
    standalone = False
  if traces:
    print 'Cannot combine traces with running a benchmark'
    usage()
else:
  standalone = True
  if not traces and not trace_manual:
    print 'Need either a set of traces (--traces= or --trace-manual) or a benchmark command line'
    usage()

if roi_only and roi_script:
  print 'Use either --roi or --roi-script but not both'
  sys.exit(-1)

if standalone:
  if use_appdebug:
    print '--appdebug not supported in standalone mode'
    sys.exit(-1)

outputdir = os.path.realpath(outputdir)
if not os.path.exists(outputdir):
  try:
    os.makedirs(outputdir)
  except OSError:
    print >> sys.stderr, 'Failed to create output directory', outputdir
    sys.exit(-1)

if heteroconfig:
  hcfgfile = os.path.join(outputdir,'sim.hetero.cfg')
  with open(hcfgfile, 'w') as fp:
    fp.write(heteroconfig)
  graphiteoptions.append('--config=%s' % hcfgfile)

if roi_only:
  graphiteoptions.append('-g --general/magic=true')
if roi_script:
  graphiteoptions.append('-g --general/roi_script=true')

if not config_file_used:
  # No config file(s) specified: prepend default Xeon X5550 Gainestown
  graphiteoptions = add_config_file('gainestown') + graphiteoptions

if scripts:
  graphiteoptions.append('-g --hooks/numscripts=%u' % len(scripts))
  for i, script in enumerate(scripts):
    if ':' in script:
      filename, args = script.split(':', 1)
    else:
      filename, args = script, None
    if os.path.isfile(filename):
      # Absolute filename?
      scriptfile = os.path.abspath(os.path.join(filename))
    else:
      # Relative filename?
      #   splashrun or a similar script may have changed the working directory since we started running.
      #   --curdir will tell us what the original directory was, use this to try and find the script
      scriptfile = os.path.abspath(os.path.join(curdir, filename))
      if not os.path.isfile(scriptfile):
        # Predefined script?
        scriptfile = os.path.join(HOME, 'scripts', filename + '.py')
        if not os.path.isfile(scriptfile):
          print 'Cannot find script file', scriptfile
          sys.exit(-1)
    graphiteoptions.append('-g --hooks/script%uname=%s' % (i, scriptfile))
    graphiteoptions.append('-g --hooks/script%uargs=%s' % (i, args or ''))

def findtrace(trace):
  for dirname in ('.', os.getenv('BENCHMARKS_TRACES', '.'), os.getenv('BENCHMARKS_ROOT', '.'), os.getenv('BENCHMARKS_ROOT_ORIG', '.')):
    for subdir in ('.', 'traces'):
      filename = os.path.realpath(os.path.join(dirname, subdir, trace))
      if os.path.exists(filename):
        return filename
      filename += '.sift'
      if os.path.exists(filename):
        return filename
  return False

# If using traces via this front-end, support either multi-program workloads or a single multi-threaded application
if traces:
  graphiteoptions.append('-g --traceinput/enabled=true')
  if resptraces:
    graphiteoptions.append('-g --traceinput/emulate_syscalls=true')
    graphiteoptions.append('-g --traceinput/num_apps=1')
  else:
    graphiteoptions.append('-g --traceinput/emulate_syscalls=false')
    graphiteoptions.append('-g --traceinput/num_apps=%u' % len(traces))
  for thread_id, trace in enumerate(traces):
    filename = findtrace(trace)
    if filename:
      print '[SNIPER] (%u) Using trace file %s' % (thread_id, filename)
      graphiteoptions.append('-g --traceinput/thread_%u=%s' % (thread_id, filename))
    else:
      print 'Cannot find trace', trace
      sys.exit(-1)
  for thread_id, trace in enumerate(resptraces):
    filename = findtrace(trace)
    if filename:
      print '[SNIPER] (%u) Using response-trace file %s' % (thread_id, filename)
      graphiteoptions.append('-g --traceinput/thread_response_%u=%s' % (thread_id, filename))
    else:
      print 'Cannot find trace', trace
      sys.exit(-1)
elif use_mpi:
  if not mpi_ranks:
    mpi_ranks = ncores
  graphiteoptions.append('-g --traceinput/enabled=true')
  graphiteoptions.append('-g --traceinput/emulate_syscalls=true')
  graphiteoptions.append('-g --traceinput/stop_with_first_thread=false') # Only stop once all MPI ranks have completed
  graphiteoptions.append('-g --traceinput/num_apps=%d' % mpi_ranks)
  basefname = 'run_benchmarks'
  tracetempdir = tempfile.mkdtemp()
  tracefiles_created = [] # FIFOs to be cleaned up
  traceprefix = os.path.join(tracetempdir, basefname)
  graphiteoptions.append('-g --traceinput/trace_prefix=%s' % traceprefix)
  # Create FIFOs for first thread of each application
  for r in range(mpi_ranks):
    for f in ('','_response'):
      filename = '%s%s.app%d.th%d.sift' % (traceprefix, f, r, 0)
      os.mkfifo(filename)
      tracefiles_created.append(filename)
  # Start app with trace recorder in a thread
  tracecmd = [ os.path.join(HOME, 'record-trace'), '-o', traceprefix, '--roi', '-e', '1', '-s', '-1', '--follow', '--' ] + cmdline
  print '[SNIPER] Running', tracecmd
  threading.Thread(target = lambda: time.sleep(1) or subprocess.Popen(tracecmd).communicate()).start()

graphiteoptions = ' '.join(graphiteoptions)

configfile = os.path.join(HOME, 'config/graphite.py')
config = {}
execfile(configfile, {}, config)

# convert paths in config to absolute paths
for d in ('pin_home',):
  absdir = os.path.join(HOME, config[d])
  if not os.path.isdir(absdir):
    sys.stderr.write('Cannot find %s %s, please check %s\n' % (d, absdir, configfile))
    sys.exit(-1)
  exec "%s = '%s'" % (d, absdir)
sim_root = HOME
arch = config.get('target', 'intel64')


# Determine libstdc++.so used by default by pin_sim.so using ldd
# Should take into account the current LD_LIBRARY_PATH
def get_cxx_inuse():
  pin_sim = '%s/lib/pin_sim.so' % sim_root
  try:
    ldd_out = subprocess.Popen(['ldd', pin_sim], stdout = subprocess.PIPE).communicate()[0]
    libcxx_path = os.path.dirname([ line.split()[2] for line in ldd_out.split('\n') if 'libstdc++.so.6' in line ][0])
  except Exception, e:
    print `e`
    return None
  return libcxx_path

# Find libstdc++.so version number in a given path
def get_cxx_version(path):
  filename = os.path.join(path, 'libstdc++.so.6')
  if os.path.exists(filename):
    realname = os.path.realpath(filename)
    try:
      version = int(realname.split('.')[-1])
      return version
    except Exception, e:
      print `e`
      return 0
  else:
    return 0

# Find which libstdc++.so is newer: either the system default one, or the Pin one
cxx_inuse = get_cxx_inuse()
cxx_inuse_version = get_cxx_version(cxx_inuse)
cxx_pin_version = get_cxx_version('%(pin_home)s/%(arch)s/runtime/cpplibs' % locals())
if cxx_inuse_version > cxx_pin_version:
  # Prepend current libstdc++.so path to LD_LIBRARY_PATH so it overrides %(pin_home)s/%(arch)s/runtime/cpplibs
  cxx_touse = cxx_inuse
else:
  # Use %(pin_home)s/%(arch)s/runtime/cpplibs as normal
  cxx_touse = ''

env = dict(os.environ)
env['LD_LIBRARY_PATH'] = ':'.join([
  cxx_touse,
  'BENCHMARKS_ROOT' in os.environ and '%s/libs:' % os.environ['BENCHMARKS_ROOT'] or '',
  '%(pin_home)s/%(arch)s/runtime/cpplibs' % locals(),
  '%(pin_home)s/%(arch)s/runtime' % locals(),
  '%(HOME)s/python_kit/%(arch)s/lib' % locals(),
  env.get('LD_LIBRARY_PATH', ''),
])
env['PYTHONPATH'] = '%(HOME)s/scripts:$PYTHONPATH' % locals()
env['GRAPHITE_ROOT'] = HOME


pin_version = 'unknown'
try:
  pin_version = subprocess.Popen(['%(pin_home)s/%(arch)s/bin/pinbin' % locals(), '-version'], stdout = subprocess.PIPE, env = env).communicate()[0]
  pin_version = int([ line.split()[3] for line in pin_version.split('\n') if line.startswith('@CHARM-VERSION') ][0])
  assert 10000 < pin_version < 1000000
except Exception, e:
  print >> sys.stderr, 'Cannot get Pin version'
  print >> sys.stderr
  print >> sys.stderr, e
  print >> sys.stderr, pin_version
  sys.exit(-1)


pinoptions = '-mt -injection child'
if pin_version >= 49303:
  pinoptions += ' -xyzzy -enable_vsm 0' # TODO: Enable vsm once OpenMP thread exit is solved (Redmine #148)

if pin_stats:
  pinoptions += ' -xyzzy -profile -statistic -log_inline'

if use_gdb:
  pinoptions += ' -pause_tool 1'

if use_appdebug:
  if appdebug_nowait:
    pinoptions += ' -appdebug_enable -appdebug_silent'
  else:
    pinoptions += ' -appdebug'


optcmd = ' -c %(sim_root)s/config/base.cfg --general/total_cores=%(ncores)u --general/output_dir=%(outputdir)s %(graphiteoptions)s' % locals()
if standalone:
  if use_gdb:
    gdbcmd = 'gdb %(HOME)s/lib/sniper --args ' % locals()
  else:
    gdbcmd = ''
  cmd = gdbcmd + '%(HOME)s/lib/sniper' % locals() + optcmd
else:
  cmd = '%(pin_home)s/%(arch)s/bin/pinbin %(pinoptions)s -t %(sim_root)s/lib/pin_sim' % locals() + optcmd + ' -- ' + ' '.join(cmdline)

queue = Queue.Queue()


memusage = 0; stopping = False
usage = None

def log_memory(pid):
  def do_log_memory():
    global memusage
    pids = set([pid])
    while not stopping:
      # find children of all known pid's
      pids.update(map(int, commands.getoutput('ps --ppid %s -o pid' % ','.join(map(str, pids))).split('\n')[1:]))
      # sum memory usage of all children
      _memusage = 0
      for _pid in pids:
        try:
          proc = file('/proc/%u/statm' % int(_pid)).read()
          _memusage += long(proc.split()[0]) * 4096
        except:
          # process already dead, or something
          pass
      memusage = max(memusage, _memusage)
      # sleep 10 seconds, in an interruptable way so we delay completion by only 1 second rather than up to 10 seconds
      for i in range(10):
        time.sleep(1)
        if stopping: break
  threading.Thread(target = do_log_memory).start()


def execute():
  global cmd, usage

  cmd = [ 'bash', '-c', cmd ]
  if use_perf:
    cmd = [ 'perf', 'record', '--force', '--output', os.path.join(outputdir, 'perf.data'), '--' ] + cmd

  print 'Running', cmd
  sys.stdout.flush()
  sys.stderr.flush()
  subproc = subprocess.Popen(cmd, env = env)

  log_memory(subproc.pid)

  try:
    pid, rc, usage = os.wait4(subproc.pid, 0)
  except KeyboardInterrupt:
    os.kill(subproc.pid, 9)
    return 9


def execute_appdebug():
  print 'Running', cmd
  sys.stdout.flush()
  sys.stderr.flush()

  p_graphite = subprocess.Popen([ 'bash', '-c', cmd ], bufsize = 1, stdout = subprocess.PIPE, env = env)
  while True:
    line = p_graphite.stdout.readline()
    if line.startswith('  target remote :'):
      info = file(os.path.join(outputdir, 'appdebug_port.out')).read()
      g_pid, g_remote = map(long, info.split())
      break

  print
  print "To interrupt the application, use: kill -INT %s" % g_pid
  print

  def output_graphite():
    while True:
      line = p_graphite.stdout.readline()
      if not line: break
      print line,
  threading.Thread(target = output_graphite).start()

  fh, fn = tempfile.mkstemp()
  f = open(fn, 'w')
  f.write('target remote :%s\n' % g_remote)
  f.close()

  return os.system('gdb -quiet -command=%s %s' % (fn, '/proc/%s/exe' % g_pid)) # /proc/<pid>/exe is a symlink to the actual binary


if save_patch:
  graphiterootdir = HOME
  gitdir = os.path.join(graphiterootdir, '.git')
  patchfile = os.path.join(outputdir, 'sim.patch')
  os.system("git --work-tree='%(graphiterootdir)s' --git-dir='%(gitdir)s' log --max-count=1 --pretty=%%H > '%(patchfile)s'" % locals())
  os.system("git --work-tree='%(graphiterootdir)s' --git-dir='%(gitdir)s' diff >> '%(patchfile)s'" % locals())

t_start = time.time()
backtracefile = os.path.join(outputdir, 'debug_backtrace.out')
try: os.unlink(backtracefile)
except: pass
print '[SNIPER] Start'

try:
  if use_gdb and not standalone:
    rc = debugpin.execute_gdb(cmd = cmd, env = env, pin_home = pin_home, arch = arch, wait = gdb_wait, quit = gdb_quit)
  elif use_appdebug and not (appdebug_manual or appdebug_nowait):
    rc = execute_appdebug()
  else:
    rc = execute()

except KeyboardInterrupt:
  # Make sure Graphite itself is stopped, even if it didn't respond to the SIGINT
  print '\n[SNIPER] Ctrl-C detected: Killing all child processes'
  time.sleep(1)
  sniper_lib.kill_children()
  sys.exit(-1)


stopping = True
t_end = time.time()
t_elapsed = t_end - t_start
print '[SNIPER] End'
print '[SNIPER] Elapsed time:', '%.02f' % t_elapsed, 'seconds'

if use_mpi:
  # Cleanup the pipes and temporary directory
  try:
    for f in tracefiles_created:
      os.unlink(f)
    os.rmdir(tracetempdir)
  except OSError:
    pass
    

if os.path.exists(backtracefile) and os.path.getsize(backtracefile) > 0:
  os.system('%(sim_root)s/tools/gen_backtrace.py "%(backtracefile)s"' % locals())

if run_power:
  print '[SNIPER] Running McPAT'
  os.system('%(sim_root)s/tools/mcpat.py -d %(outputdir)s -o %(outputdir)s/power' % locals())

stats = dict(
  host = platform.node(),
  user = os.getenv('USER') or os.getenv('USERNAME'),
  git_revision = config.get('git_revision', ''),
  pin_version = pin_version,
  cmdline = sys.argv,
  graphitecmd = cmd,
  vmem = memusage,
  rusage = usage and tuple(usage) or None,
  t_start = t_start,
  t_elapsed = t_elapsed,
)
if 'BENCHMARKS_ROOT' in os.environ:
  stats['benchmarks_root'] = os.getenv('BENCHMARKS_ROOT'),
  stats['benchmarks_revision'] = commands.getoutput('cd $BENCHMARKS_ROOT && (if [ -e .git ]; then git rev-parse HEAD; else cat .gitid; fi)'),
file(os.path.join(outputdir, 'graphite.out'), 'w').write(pprint.pformat(stats))

if os.path.exists('pin.log') and os.path.realpath(os.getcwd()) != os.path.realpath(outputdir):
  os.system('cp pin.log %s' % outputdir)

simoutfile = os.path.join(outputdir, 'sim.out')
if os.path.exists(simoutfile): os.unlink(simoutfile)
gen_simout.generate_simout(resultsdir = outputdir, output = open(simoutfile, 'w'), silent = True)

sys.exit(rc)
