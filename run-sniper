#!/usr/bin/env python

import sys, os, time, getopt, tempfile, subprocess, threading, platform, pprint, Queue, socket, pipes, commands
sys.path.append(os.path.join(os.path.dirname(__file__), 'tools'))
import sniper_lib, sniper_config, gen_simout, debugpin, env_setup, run_sniper


HOME = env_setup.sim_root()


def usage():
  print 'Run program under the Sniper simulator'
  print 'Usage:'
  print '  %s  [-n <ncores (1)>]  [-d <outputdir (.)>]  [-c <sniper-config>]  [-c [objname:]<name[.cfg]>,<name2[.cfg]>,...]  [-g <sniper-options>]  [-s <script>]  [--roi]  [--roi-script]  [--viz]  [--perf]  [--gdb]  [--gdb-wait]  [--gdb-quit]  [--appdebug]  [--appdebug-manual]  [--appdebug-enable]  [--power]  [--cache-only]  [--fast-forward]  [--no-cache-warming]  [--save-patch]  [--pin-stats]  [--mpi [--mpi-ranks=<ranks>] ]  {--traces=<trace0>,<trace1>,... [--sim-end=<first|last|last-restart (default: first)>]  |  --pinballs=<pinball-basename>,*  |  -- <cmdline> }' % sys.argv[0]
  print
  print 'Example: $ ./run-sniper -- /bin/ls'
  print
  print 'Note: To get started quickly with our integrated benchmarks distribution (supports SPLASH-2 and PARSEC 2.1),'
  print ' see http://snipersim.org/w/Download_Benchmarks'
  print
  sys.exit(2)

standalone = False
ncores = 1
outputdir = '.'
configfiles = []
sniperoptions = []
roi_only = False
roi_script = False
sim_end = 'first'
sim_end_valid = ('first', 'last', 'last-restart')
use_viz = False
use_viz_mcpat = ''
use_perf = False
use_valgrind = False
use_gdb = False
gdb_wait = False
gdb_quit = False
use_appdebug = False
appdebug_manual = False
appdebug_nowait = False
run_power = False
save_patch = False
pin_stats = False
curdir = os.getcwd()
scripts = []
use_mpi = False
mpi_ranks = 0
traces = []
resptraces = []
trace_manual = False
heteroconfig = None
pinballs = None
pinball_sift = True
tracegen = None

if not sys.argv[1:]:
  usage()

def findconfig(filename, extension = '.cfg'):
  for dirname in ('.', os.path.join(HOME, 'config')):
    configfile = os.path.realpath(os.path.join(dirname, filename))
    if os.path.isfile(configfile):
      return configfile
    configfile += extension
    if os.path.isfile(configfile):
      return configfile
  return False

def add_config_file(filename, extension = '.cfg'):
  config_files = []
  configfile = findconfig(filename, extension)
  if not configfile:
    print >> sys.stderr, 'Cannot find config file', filename
    sys.exit(1)
  # Handle #include
  for line in file(configfile):
    if line.startswith('#include'):
      config_files += add_config_file(line.split()[1], extension)
  config_files.append(configfile)
  return config_files

def make_hetero_config(confignames, objname='core', extension='.cfg'):
  configfiles = map(lambda x:findconfig(x,extension), confignames)
  if not all(configfiles):
    notfound = [ name for name, found in zip(confignames, configfiles) if not found ]
    print >> sys.stderr, 'Config file not found:', ', '.join(notfound)
    sys.exit(1)
  configfiledata = map(lambda x:open(x).read(), configfiles)
  configs = map(sniper_config.parse_config, configfiledata)

  # Generate a set of all config options
  opts = set()
  for config in configs:
    for key in config.keys():
      opts.add(key)

  # Combine all of the heterogeneous configurations
  newconfig = ''
  newconfig += '# Generated from ' + ', '.join(set(configfiles)) + '\n'
  for opt in opts:
    title, _, key = opt.rpartition('/')
    newconfig += '[%s]\n%s=' % (title,key)
    heteroopts = []
    for config in configs:
      if opt in config:
        heteroopts.append(config[opt])
      else:
        heteroopts.append('')
    newconfig += ','.join(heteroopts)+'\n'

  # Create initial tags for the heterogeneous configurations
  # The tags are the basename without the extension.
  # config/big.cfg with have the tag 'big'
  tags = map(lambda x:os.path.splitext(os.path.split(x)[1])[0], configfiles)
  for tag in set(tags):
    enabled = map(lambda x:(x == tag) and '1' or '0', tags)
    newconfig += '[tags/%s]\n' % objname
    newconfig += '%s=%s\n' % (tag,','.join(enabled))

  return newconfig


try:
  opts, cmdline = getopt.getopt(sys.argv[1:], "hn:m:d:c:g:s:", [ "roi", "roi-script", "viz", "perf", "valgrind", "gdb", "gdb-wait", "gdb-quit", "appdebug", "appdebug-manual", "appdebug-enable", "power", "cache-only", "fast-forward", "no-cache-warming", "save-patch", "curdir=", "pin-stats", "traces=", "response-traces=", "trace-manual", "sim-end=", "mpi", "mpi-ranks=", "pinballs=", "pinball-non-sift" ])
except getopt.GetoptError, e:
  # print help information and exit:
  print >> sys.stderr, e
  usage()
for o, a in opts:
  if o == '-h':
    usage()
    sys.exit()
  if o == '-n':
    ncores = int(a)
  if o == '-d':
    outputdir = a
  if o == '-c':
    if ':' in a or ',' in a:
      obj, _, cfg = a.rpartition(':')
      if not obj:
        obj = 'core'
      heteroconfig = make_hetero_config(cfg.split(','), objname=obj)
    else:
      configfiles.extend(add_config_file(a))
  if o == '-g':
    if not a.startswith('-'):
      a = '--'+a
    sniperoptions.append(pipes.quote(a))
  if o == '--roi':
    roi_only = True
  if o == '--roi-script':
    roi_script = True
  if o == '--sim-end':
    if a not in sim_end_valid:
      print >> sys.stderr, '--sim-end value', a, 'invalid, need one of', sim_end_valid
      sys.exit(1)
    sim_end = a
  if o == '-s':
    scripts.append(a)
  if o == '--viz':
    use_viz = True
  if o == '--perf':
    use_perf = True
  if o == '--valgrind':
    use_valgrind = True
  if o == '--gdb':
    use_gdb = True
  if o == '--gdb-wait':
    use_gdb = True
    gdb_wait = True
  if o == '--gdb-quit':
    use_gdb = True
    gdb_wait = False
    gdb_quit = True
  if o == '--appdebug':
    use_appdebug = True
  if o == '--appdebug-manual':
    use_appdebug = True
    appdebug_manual = True
  if o == '--appdebug-enable':
    use_appdebug = True
    appdebug_nowait = True
  if o == '--power':
    run_power = True
    use_viz_mcpat = '--mcpat'
  if o == '--cache-only':
    sniperoptions.append('-g --general/inst_mode_roi=cache_only')
  if o == '--fast-forward':
    sniperoptions.append('-g --general/inst_mode_init=fast_forward')
    sniperoptions.append('-g --general/inst_mode_roi=fast_forward')
  if o == '--no-cache-warming':
    sniperoptions.append('-g --general/inst_mode_init=fast_forward')
  if o == '--save-patch':
    save_patch = True
  if o == '--pin-stats':
    pin_stats = True
  if o == '--curdir':
    curdir = a
  if o == '--traces':
    traces.extend(a.split(','))
  if o == '--response-traces':
    resptraces.extend(a.split(','))
  if o == '--trace-manual':
    trace_manual = True
  if o == '--mpi':
    use_mpi = True
  if o == '--mpi-ranks':
    mpi_ranks = long(a)
  if o == '--pinballs':
    pinballs = a.split(',')
  if o == '--pinball-non-sift':
    pinball_sift = False



def findtrace(trace, suffix = '.sift'):
  for dirname in ('.', os.getenv('BENCHMARKS_TRACES', '.'), os.getenv('BENCHMARKS_ROOT', '.'), os.getenv('BENCHMARKS_ROOT_ORIG', '.')):
    for subdir in ('.', 'traces'):
      filename = os.path.realpath(os.path.join(dirname, subdir, trace))
      if os.path.exists(filename):
        return filename
      filename += suffix
      if os.path.exists(filename):
        return filename
  return False

if cmdline:
  if use_mpi:
    standalone = True
  else:
    standalone = False
  if traces or trace_manual:
    print >> sys.stderr, 'Cannot combine traces with running a benchmark'
    usage()
  if pinballs:
    print >> sys.stderr, 'Cannot combine pinball use with running a benchmark'
    usage()
elif pinballs:
  if len(pinballs) > 1 and not pinball_sift:
    print >> sys.stderr, 'Cannot run multiple non-SIFT pinballs'
    usage()
  if sim_end.endswith('-restart'):
    print >> sys.stderr, 'Restart not supported in PinPlay mode'
    usage()
  standalone = pinball_sift
  if traces or trace_manual:
    print >> sys.stderr, 'Cannot combine a pinball with tracing (--traces= or --trace-manual)'
    usage()
  for idx, pinball in enumerate(pinballs[:]):
    pinball = findtrace(pinball, suffix='.address')
    if not pinball:
      pinball = pinball.rpartition('.')[0]
      print >> sys.stderr, 'Unable to locate a pinball at (%s), make sure that (%s.address) exists.' % (pinball, pinball)
      usage()
    else:
      pinballs[idx] = pinball.rpartition('.')[0]
else:
  standalone = True
  opt_count = 0
  if traces:
    opt_count+=1
  if trace_manual:
    opt_count+=1
  if opt_count == 0:
    print >> sys.stderr, 'Need either a set of traces (--traces= or --trace-manual), a pinball, or a benchmark command line'
    usage()
  if opt_count > 1:
    print >> sys.stderr, 'Can only use one of --traces=, --trace-manual or --pinballs= when not using a command line argument'
    usage()

if roi_only and roi_script:
  print >> sys.stderr, 'Use either --roi or --roi-script but not both'
  sys.exit(-1)

if standalone:
  if use_appdebug:
    print >> sys.stderr, '--appdebug not supported in standalone mode'
    sys.exit(-1)
  if use_valgrind and use_gdb:
    print >> sys.stderr, 'Cannot use both --valgrind and --gdb at the same time'
    sys.exit(-1)
else:
  if use_valgrind:
    print >> sys.stderr, '--valgrind only supported in standalone mode'
    sys.exit(-1)

outputdir = os.path.realpath(outputdir)
if not os.path.exists(outputdir):
  try:
    os.makedirs(outputdir)
  except OSError:
    print >> sys.stderr, 'Failed to create output directory', outputdir
    sys.exit(-1)

if heteroconfig:
  hcfgfile = os.path.join(outputdir,'sim.hetero.cfg')
  fp = open(hcfgfile, 'w')
  fp.write(heteroconfig)
  fp.close()
  configfiles.append(hcfgfile)

if not configfiles:
  # No config file(s) specified: prepend default Xeon X5550 Gainestown
  configfiles = add_config_file('gainestown')
# Prepend config files to options, so -g options are always later on the command line and override config files
sniperoptions = [ '--config=%s' % cfgfile for cfgfile in configfiles ] + sniperoptions

if roi_only:
  sniperoptions.append('-g --general/magic=true')
if roi_script:
  sniperoptions.append('-g --general/roi_script=true')

if sim_end == 'first':
  sniperoptions.append('-g --traceinput/stop_with_first_app=true')
  sniperoptions.append('-g --traceinput/restart_apps=false')
elif sim_end == 'last':
  sniperoptions.append('-g --traceinput/stop_with_first_app=false')
  sniperoptions.append('-g --traceinput/restart_apps=false')
elif sim_end == 'last-restart':
  sniperoptions.append('-g --traceinput/stop_with_first_app=false')
  sniperoptions.append('-g --traceinput/restart_apps=true')

if use_viz:
  scripts.append('periodic-stats:1000:2000')
  scripts.append('markers:markers')

if scripts:
  sniperoptions.append('-g --hooks/numscripts=%u' % len(scripts))
  for i, script in enumerate(scripts):
    if ':' in script:
      filename, args = script.split(':', 1)
    else:
      filename, args = script, None
    if os.path.isfile(filename):
      # Absolute filename?
      scriptfile = os.path.abspath(os.path.join(filename))
    else:
      # Relative filename?
      #   splashrun or a similar script may have changed the working directory since we started running.
      #   --curdir will tell us what the original directory was, use this to try and find the script
      scriptfile = os.path.abspath(os.path.join(curdir, filename))
      if not os.path.isfile(scriptfile):
        # Predefined script?
        scriptfile = os.path.join(HOME, 'scripts', filename + '.py')
        if not os.path.isfile(scriptfile):
          print >> sys.stderr, 'Cannot find script file', scriptfile
          sys.exit(-1)
    sniperoptions.append('-g --hooks/script%uname=%s' % (i, scriptfile))
    sniperoptions.append('-g --hooks/script%uargs=%s' % (i, args or ''))

# If using traces via this front-end, support either multi-program workloads or a single multi-threaded application
if traces:
  sniperoptions.append('-g --traceinput/enabled=true')
  if resptraces:
    sniperoptions.append('-g --traceinput/emulate_syscalls=true')
    sniperoptions.append('-g --traceinput/num_apps=1')
  else:
    sniperoptions.append('-g --traceinput/emulate_syscalls=false')
    sniperoptions.append('-g --traceinput/mirror_output=true') # Stored traces: mirror output
    sniperoptions.append('-g --traceinput/num_apps=%u' % len(traces))
  for thread_id, trace in enumerate(traces):
    filename = findtrace(trace, suffix='.sift')
    if filename:
      print '[SNIPER] (%u) Using trace file %s' % (thread_id, filename)
      sniperoptions.append('-g --traceinput/thread_%u=%s' % (thread_id, filename))
    else:
      print >> sys.stderr, 'Cannot find trace', trace
      sys.exit(-1)
  for thread_id, trace in enumerate(resptraces):
    filename = findtrace(trace, suffix='.sift')
    if filename:
      print '[SNIPER] (%u) Using response-trace file %s' % (thread_id, filename)
      sniperoptions.append('-g --traceinput/thread_response_%u=%s' % (thread_id, filename))
    else:
      print >> sys.stderr, 'Cannot find trace', trace
      sys.exit(-1)
elif use_mpi:
  tracegen = {}
  if not mpi_ranks:
    mpi_ranks = ncores
  tracegen['enabled'] = 'true'
  tracegen['emulate_syscalls'] = 'true'
  tracegen['num_apps'] = mpi_ranks
  sniperoptions.append('-g --traceinput/stop_with_first_app=false') # Only stop once all MPI ranks have completed
  # Set trace recorder options
  applications = [
    [ '--roi', '-e', '1', '-s', '-1', '-r', '1', '--follow', '--pa', '--' ] + cmdline
  ]
elif pinballs and pinball_sift:
  tracegen = {}
  tracegen['enabled'] = 'true'
  tracegen['emulate_syscalls'] = 'false'
  tracegen['num_apps'] = len(pinballs)
  # Set trace recorder options
  applications = []
  for app_id, pinball in enumerate(pinballs):
    applications.append([ '-e', '0', '-s', str(app_id), '-r', '1', '--pinball', pinball, '--outputdir', outputdir ])

# Setup common generated trace files
if tracegen:
  tracegen['enabled'] = 'true'
  sniperoptions.append('-g --traceinput/enabled=%s' % tracegen['enabled'])
  sniperoptions.append('-g --traceinput/emulate_syscalls=%s' % tracegen['emulate_syscalls'])
  sniperoptions.append('-g --traceinput/num_apps=%d' % tracegen['num_apps'])
  basefname = 'run_benchmarks'
  tracegen['tracetempdir'] = tempfile.mkdtemp()
  tracegen['tracefiles_created'] = [] # FIFOs to be cleaned up
  traceprefix = os.path.join(tracegen['tracetempdir'], basefname)
  sniperoptions.append('-g --traceinput/trace_prefix=%s' % traceprefix)
  # Create FIFOs for first thread of each application
  for r in range(tracegen['num_apps']):
    for f in ('','_response'):
      filename = '%s%s.app%d.th%d.sift' % (traceprefix, f, r, 0)
      os.mkfifo(filename)
      tracegen['tracefiles_created'].append(filename)
  # Start app(s) with trace recorder in a thread
  def run_sift_recorder(app_cmd):
    tracecmd = [ os.path.join(HOME, 'record-trace'), '-o', traceprefix ] + app_cmd
    print '[SNIPER] Running', tracecmd
    time.sleep(1)
    subprocess.Popen(tracecmd).communicate()
  for app_id, app_cmd in enumerate(applications):
    if True: # redirect output
      threading.Thread(target = run_sniper.run_program_redirect, args = (app_id, run_sift_recorder, app_cmd, outputdir)).start()
    else:    # inline output
      threading.Thread(target = run_sift_recorder, args = (app_cmd,)).start()

sniperoptions = ' '.join(sniperoptions)

configfile = os.path.join(HOME, 'config/sniper.py')
config = {}
execfile(configfile, {}, config)

# convert paths in config to absolute paths
for d in ('pin_home',):
  absdir = os.path.join(HOME, config[d])
  if not os.path.isdir(absdir):
    sys.stderr.write('Cannot find %s %s, please check %s\n' % (d, absdir, configfile))
    sys.exit(-1)
  exec "%s = '%s'" % (d, absdir)
sim_root = HOME
arch = config.get('target', 'intel64')


# Determine libstdc++.so used by default by pin_sim.so using ldd
# Should take into account the current LD_LIBRARY_PATH
def get_cxx_inuse():
  pin_sim = '%s/lib/pin_sim.so' % sim_root
  try:
    ldd_out = subprocess.Popen(['ldd', pin_sim], stdout = subprocess.PIPE, stderr = open('/dev/null','w')).communicate()[0]
    libcxx_path = os.path.dirname([ line.split()[2] for line in ldd_out.split('\n') if 'libstdc++.so.6' in line ][0])
  except Exception, e:
    print >> sys.stderr, `e`
    return None
  return libcxx_path

# Find libstdc++.so version number in a given path
def get_cxx_version(path):
  filename = os.path.join(path, 'libstdc++.so.6')
  if os.path.exists(filename):
    realname = os.path.realpath(filename)
    try:
      version = int(realname.split('.')[-1])
      return version
    except Exception, e:
      print >> sys.stderr, `e`
      return 0
  else:
    return 0

if not standalone:
  # Find which libstdc++.so is newer: either the system default one, or the Pin one
  cxx_inuse = get_cxx_inuse()
  cxx_inuse_version = get_cxx_version(cxx_inuse)
  cxx_pin_version = get_cxx_version('%(pin_home)s/%(arch)s/runtime/cpplibs' % locals())
  if cxx_inuse_version > cxx_pin_version:
    # Prepend current libstdc++.so path to LD_LIBRARY_PATH so it overrides %(pin_home)s/%(arch)s/runtime/cpplibs
    cxx_touse = cxx_inuse
  else:
    # Use %(pin_home)s/%(arch)s/runtime/cpplibs as normal
    cxx_touse = ''
else:
  cxx_touse = ''

env = dict(os.environ)
ld_library_path_orig = env.get('LD_LIBRARY_PATH', '')
ld_library_path = []
if cxx_touse:
  ld_library_path.append(cxx_touse)
if 'BENCHMARKS_ROOT' in os.environ:
  ld_library_path.append('%s/libs:' % os.environ['BENCHMARKS_ROOT'])
if not standalone:
  ld_library_path.append('%(pin_home)s/%(arch)s/runtime/cpplibs' % locals())
  ld_library_path.append('%(pin_home)s/%(arch)s/runtime' % locals())
ld_library_path.append('%(HOME)s/python_kit/%(arch)s/lib' % locals())
ld_library_path.append(ld_library_path_orig)
env['LD_LIBRARY_PATH'] = ':'.join(ld_library_path)
env['PIN_LD_RESTORE_REQUIRED'] = '1'
env['PIN_VM_LD_LIBRARY_PATH'] = env['LD_LIBRARY_PATH'] # Pin VM and Pintool (Sniper) use LD_LIBRARY_PATH as modified above
env['PIN_APP_LD_LIBRARY_PATH'] = ld_library_path_orig  # Application uses original LD_LIBRARY_PATH
env['PYTHONPATH'] = '%(HOME)s/scripts:$PYTHONPATH' % locals()
env['SNIPER_ROOT'] = HOME
env['GRAPHITE_ROOT'] = HOME


optcmd = ''
pin_version = 'unknown'
pinoptions = ''
if not standalone:
  try:
    pin_version = subprocess.Popen(['%(pin_home)s/%(arch)s/bin/pinbin' % locals(), '-version'], stdout = subprocess.PIPE, env = env).communicate()[0]
    pin_version = int([ line.split()[3] for line in pin_version.split('\n') if line.startswith('@CHARM-VERSION') ][0])
    assert 10000 < pin_version < 1000000
  except Exception, e:
    print >> sys.stderr, 'Cannot get Pin version'
    print >> sys.stderr
    print >> sys.stderr, e
    print >> sys.stderr, pin_version
    sys.exit(-1)

  pinoptions = '-mt -injection child'
  if pin_version >= 49303:
    pinoptions += ' -xyzzy -enable_vsm 0' # TODO: Enable vsm once OpenMP thread exit is solved (Redmine #148)

  if pin_stats:
    pinoptions += ' -xyzzy -profile -statistic -log_inline'

  if use_gdb:
    pinoptions += ' -pause_tool 1'

  if use_appdebug:
    if appdebug_nowait:
      pinoptions += ' -appdebug_enable -appdebug_silent'
    else:
      pinoptions += ' -appdebug'

if pinballs and not pinball_sift:
  pinoptions += ' -xyzzy -reserve_memory "%s.address"' % (pinballs[0])
  optcmd += ' -replay -replay:basename "%s" -pinplay:msgfile "%s" -replay:resultfile "%s" --general/enable_pinplay=true' % (pinballs[0], os.path.join(outputdir,'pinball_replay'), os.path.join(outputdir,'pinball_result'))
  # Overwrite the cmdline with the nullapp, as the pinball will handle the appropriate processing
  nullapp_path = '%(pin_home)s/extras/pinplay/bin/%(arch)s/nullapp' % locals()
  if not os.path.exists(nullapp_path):
    print >> sys.stderr, "Error: Unable to locate PinPlay's nullapp to play back a pinball"
    sys.exit(1)
  cmdline = [nullapp_path]

optcmd += ' -c %(sim_root)s/config/base.cfg --general/total_cores=%(ncores)u --general/output_dir=%(outputdir)s %(sniperoptions)s' % locals()
if standalone:
  if use_gdb:
    fh, fn = tempfile.mkstemp()
    f = open(fn, 'w')
    # When using GDB in standalone mode, do not set the LD_LIBRARY_PATH for GDB, but instead set the shared library path inside GDB for debugging Sniper-standalone
    f.write("set environment LD_LIBRARY_PATH = '%s'\n" % env['LD_LIBRARY_PATH'])
    del env['LD_LIBRARY_PATH']
    # Create a GDB command file to handle --gdb, --gdb-wait and --gdb-quit for standalone mode
    if not gdb_wait:
      f.write('run\n')
    # Only quit GDB when we have not seen a signal
    if gdb_quit:
      f.write('if ($_siginfo)\n')
      f.write('else \n')
      f.write(' quit\n')
      f.write('end\n')
    f.close()
    gdbcmd = 'gdb -quiet --command=%(fn)s %(HOME)s/lib/sniper --args ' % locals()
  elif use_valgrind:
    gdbcmd = 'valgrind '
  else:
    gdbcmd = ''
  cmd = gdbcmd + '%(HOME)s/lib/sniper' % locals() + optcmd
else:
  cmd = '%(pin_home)s/%(arch)s/bin/pinbin %(pinoptions)s -t %(sim_root)s/lib/pin_sim' % locals() + optcmd + ' -- ' + ' '.join(cmdline)

queue = Queue.Queue()


memusage = 0; stopping = False
usage = None

def log_memory(pid):
  def do_log_memory():
    global memusage
    while not stopping:
      # find children of all known pid's
      pids = sniper_lib.find_children(pid)
      # sum memory usage of all children
      _memusage = 0
      for _pid in pids:
        try:
          proc = file('/proc/%u/statm' % int(_pid)).read()
          _memusage += long(proc.split()[0]) * 4096
        except:
          # process already dead, or something
          pass
      memusage = max(memusage, _memusage)
      # sleep 10 seconds, in an interruptable way so we delay completion by only 1 second rather than up to 10 seconds
      for i in range(10):
        time.sleep(1)
        if stopping: break
  threading.Thread(target = do_log_memory).start()


def execute():
  global cmd, usage

  cmd = [ 'bash', '-c', cmd ]
  if use_perf:
    cmd = [ 'perf', 'record', '--force', '--output', os.path.join(outputdir, 'perf.data'), '--' ] + cmd

  print 'Running', cmd
  sys.stdout.flush()
  sys.stderr.flush()
  subproc = subprocess.Popen(cmd, env = env)

  log_memory(subproc.pid)

  try:
    try:
      pid, rc, usage = os.wait4(subproc.pid, 0)
    except AttributeError:
      pid, rc = os.waitpid(subproc.pid, 0)
  except KeyboardInterrupt:
    try:
      os.kill(subproc.pid, 9)
    except OSError:
      # Already dead, never mind
      pass
    return 9

  rc >>= 8
  return rc

def execute_appdebug():
  print 'Running', cmd
  sys.stdout.flush()
  sys.stderr.flush()

  p_sniper = subprocess.Popen([ 'bash', '-c', cmd ], bufsize = 1, stdout = subprocess.PIPE, env = env)
  while True:
    line = p_sniper.stdout.readline()
    if line.startswith('  target remote :'):
      info = file(os.path.join(outputdir, 'appdebug_port.out')).read()
      g_pid, g_remote = map(long, info.split())
      break

  print
  print "To interrupt the application, use: kill -INT %s" % g_pid
  print

  def output_sniper():
    while True:
      line = p_sniper.stdout.readline()
      if not line: break
      print line,
  threading.Thread(target = output_sniper).start()

  fh, fn = tempfile.mkstemp()
  f = open(fn, 'w')
  f.write('target remote :%s\n' % g_remote)
  f.close()

  rc = os.system('gdb -quiet -command=%s %s' % (fn, '/proc/%s/exe' % g_pid)) # /proc/<pid>/exe is a symlink to the actual binary
  rc >>= 8

  return rc


if save_patch:
  sniperrootdir = HOME
  gitdir = os.path.join(sniperrootdir, '.git')
  patchfile = os.path.join(outputdir, 'sim.patch')
  os.system("git --work-tree='%(sniperrootdir)s' --git-dir='%(gitdir)s' log --max-count=1 --pretty=%%H > '%(patchfile)s'" % locals())
  os.system("git --work-tree='%(sniperrootdir)s' --git-dir='%(gitdir)s' diff >> '%(patchfile)s'" % locals())

backtracefile = os.path.join(outputdir, 'debug_backtrace.out')
for filetodelete in (backtracefile, 'sim.out', 'sim.cfg', 'sim.info', 'sim.stats.sqlite3', 'pin.log'):
  filetodelete = os.path.join(outputdir, filetodelete)
  try: os.unlink(filetodelete)
  except OSError: pass
# Pin creates a pin.log file in os.getcwd() when there is a crash. Delete the old version as to not copy it to the outputdir
try: os.unlink('pin.log')
except OSError: pass
t_start = time.time()
print '[SNIPER] Start'

try:
  if use_gdb and not standalone:
    rc = debugpin.execute_gdb(cmd = cmd, env = env, pin_home = pin_home, arch = arch, wait = gdb_wait, quit = gdb_quit)
  elif use_appdebug and not (appdebug_manual or appdebug_nowait):
    rc = execute_appdebug()
  else:
    rc = execute()

except KeyboardInterrupt:
  # Make sure Sniper itself is stopped, even if it didn't respond to the SIGINT
  print '\n[SNIPER] Ctrl-C detected: Killing all child processes'
  time.sleep(1)
  sniper_lib.kill_children()
  sys.exit(-1)


stopping = True
t_end = time.time()
t_elapsed = t_end - t_start
print '[SNIPER] End'
print '[SNIPER] Elapsed time:', '%.02f' % t_elapsed, 'seconds'

if tracegen:
  # Cleanup the pipes and temporary directory
  try:
    for f in tracegen['tracefiles_created']:
      os.unlink(f)
    os.rmdir(tracegen['tracetempdir'])
  except OSError:
    pass


if os.path.exists(backtracefile) and os.path.getsize(backtracefile) > 0:
  os.system('%(sim_root)s/tools/gen_backtrace.py "%(backtracefile)s"' % locals())

if run_power:
  print '[SNIPER] Running McPAT'
  os.system('%(sim_root)s/tools/mcpat.py -d %(outputdir)s -o %(outputdir)s/power' % locals())

if use_viz:
  print '[SNIPER] Generating visualization in viz/'
  os.system('%(sim_root)s/tools/viz/viz.py %(use_viz_mcpat)s -d %(outputdir)s -o %(outputdir)s/viz >/dev/null' % locals())

stats = dict(
  host = platform.node(),
  user = os.getenv('USER') or os.getenv('USERNAME'),
  git_revision = config.get('git_revision', ''),
  pin_version = pin_version,
  cmdline = sys.argv,
  snipercmd = cmd,
  vmem = memusage,
  rusage = usage and tuple(usage) or None,
  t_start = t_start,
  t_elapsed = t_elapsed,
)
if 'BENCHMARKS_ROOT' in os.environ:
  stats['benchmarks_root'] = os.getenv('BENCHMARKS_ROOT'),
  stats['benchmarks_revision'] = commands.getoutput('cd $BENCHMARKS_ROOT && (if [ -e .git ]; then git rev-parse HEAD; else cat .gitid; fi)'),
file(os.path.join(outputdir, 'sim.info'), 'w').write(pprint.pformat(stats))

if os.path.exists('pin.log') and os.path.realpath(os.getcwd()) != os.path.realpath(outputdir):
  os.system('cp pin.log %s' % outputdir)

simoutfile = os.path.join(outputdir, 'sim.out')
if os.path.exists(simoutfile): os.unlink(simoutfile)
gen_simout.generate_simout(resultsdir = outputdir, output = open(simoutfile, 'w'), silent = True)

sys.exit(rc)
